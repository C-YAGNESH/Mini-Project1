# -*- coding: utf-8 -*-
"""CY_Connect4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-Y4Y42EZH8NMRBB0l66o6k7kR9eih2-x
"""

# Tic-Tac-Toe Game
#Executed by Yagnesh Challagundla

class ConnectFour:
    def __init__(self):
        # Initializing the start of the game
        self.present_position = self.present_start_board()
        # Seting the starting player to 'X'
        self.present_player = 'X'
        # labelling the columns
        self.col_labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g']

    def present_start_board(self):
        # Creating a 6x7 grid
        return [[' ' for _ in range(7)] for _ in range(6)]

    def printBoard(self):
        # Iterating through rows in reverse order to satisfy the output present in the test case
        for idx in range(5, -1, -1):
            print(f"| {idx + 1} |", end="")
            for col in range(7):
                print(f" {self.present_position[idx][col]} ", end="|")
            # Print newline and horizontal separator
            print("\n" + "-" * 33)
        # Printing column labels so that it will be easy for understanding
        print("|R/C| a | b | c | d | e | f | g |")
        # Printing bottom line to satisfy test case output file
        print("-" * 33)

    def availablePosition(self):
        empty_positions = []
        # Checking each column for the lowest empty position
        for column in self.col_labels:
            for row in range(6):
                if self.present_position[row][self.col_labels.index(column)] == ' ':
                    empty_positions.append(f"{column}{row + 1}")
                    break
        return empty_positions

    def validateEntry(self, board, col, row):
        # Check if the column is valid
        if col in self.col_labels:
            col_idx = self.col_labels.index(col)
            if 0 <= row < 6 and board[row][col_idx] == ' ':
                return "legal"
            return "full"
        return "illegal"

    def checkFull(self):
        return all(self.present_position[5][col] != ' ' for col in range(7))

    def checkWin(self, board, turn):
        for r in range(6):
            for c in range(7):
                if board[r][c] == turn:
                    # Checking horizontal, vertical, and both diagonals
                    if (self.has_consecutive(board, r, c, 0, 1, turn) or
                        self.has_consecutive(board, r, c, 1, 0, turn) or
                        self.has_consecutive(board, r, c, 1, 1, turn) or
                        self.has_consecutive(board, r, c, 1, -1, turn)):
                        return True
        return False

    def has_consecutive(self, board_state, r, c, row_increment, col_increment, player):
        count = 0
        for i in range(4):
            r_next = r + i * row_increment
            c_next = c + i * col_increment
            # Checking if the position is valid and contains the player's piece
            if 0 <= r_next < 6 and 0 <= c_next < 7 and board_state[r_next][c_next] == player:
                count += 1
            else:
                break
        return count == 4

    def checkEnd(self, board, turn):
        if self.checkWin(board, turn):
            return True
        if self.checkFull():
            return True
        return False

    def updating_move(self, column, row):
        # Converting column letter to index
        col_idx = self.col_labels.index(column)
        # Adjusting row number to match array indexing
        row_idx = row - 1
        # Checking if the cell is empty
        if self.present_position[row_idx][col_idx] == ' ':
            # Place the player's piece
            self.present_position[row_idx][col_idx] = self.present_player
            return True
        else:
            return "occupied"

    def looping(self):
        print("Starting Game: X goes first.")
        self.printBoard()
        while True:
            print(f"\n{self.present_player}'s turn.")
            print("Where do you want your", self.present_player, "placed?")
            # Geting and displaying available positions
            available_positions = self.availablePosition()
            print(f"Available positions are: {available_positions}\n")

            while True:
                # Geting player's move
                move = input("Please enter column-letter and row-number (e.g., a1): ").strip().lower()
                if len(move) < 2:
                    print("Invalid input. Enter a column letter and row number (e.g., a1).")
                    continue

                column = move[0]
                row_num = move[1:]

                # Validating row number of the board
                if not row_num.isdigit() or int(row_num) > 6 or int(row_num) < 1:
                    print("Invalid row number. Enter a valid row number between 1 and 6.")
                    continue

                # Validating the column letter of the board
                if column not in self.col_labels:
                    print("Invalid input. Enter a valid column letter between a and g.")
                    continue

                # Attempting to make the moves here
                move_result = self.updating_move(column, int(row_num))

                if move_result == True:
                    print("Thank you for your selection.")
                    break
                elif move_result == "occupied":
                    print("That cell is already taken. Choose another cell.")
                else:
                    print("Illegal move. Try again.")

            self.printBoard() # Used to Display updated board

            # Verifying whether an game has ended
            if self.checkEnd(self.present_position, self.present_player):
                if self.checkWin(self.present_position, self.present_player):
                    print(f"{self.present_player} IS THE WINNER!!!")
                else:
                    print("DRAW! The board is completely filled.")
                replay = input("Another game (y/n)? ")
                if replay[0].lower() == 'y':
                    # Reseting the game to be started
                    self.present_position = self.present_start_board()
                    print("New Game: X goes first.")
                    self.printBoard()
                    self.present_player = 'X'
                    continue
                else:
                    print("Thank you for playing!")
                    break
            self.present_player = 'O' if self.present_player == 'X' else 'X'

def main():
    # Creating a new game
    game_instance = ConnectFour()
    # Starting the game loop
    game_instance.looping()

if __name__ == "__main__":
    main()

class ConnectFour:
    def __init__(self):
        # Initialize the game board
        self.grid = self.resetBoard()
        # Set the starting player to 'X'
        self.active_player = 'X'
        # Define column labels for the game board
        self.col_labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g']

    def resetBoard(self):
        # Create a 6x7 grid filled with empty spaces
        return [[' ' for _ in range(7)] for _ in range(6)]

    def printBoard(self):
        # Iterate through rows in reverse order (bottom to top)
        for idx in range(5, -1, -1):
            # Print row number
            print(f"| {idx + 1} |", end="")
            # Print each cell in the row
            for col in range(7):
                print(f" {self.grid[idx][col]} ", end="|")
            # Print newline and horizontal separator
            print("\n" + "-" * 33)
        # Print column labels
        print("|R/C| a | b | c | d | e | f | g |")
        # Print bottom border
        print("-" * 33)

    def availablePosition(self):
        empty_positions = []
        # Check each column for the lowest empty position
        for column in self.col_labels:
            for row in range(6):
                if self.grid[row][self.col_labels.index(column)] == ' ':
                    # Add the position to the list and move to next column
                    empty_positions.append(f"{column}{row + 1}")
                    break
        return empty_positions

    def validateEntry(self, board, col, row):
        # Check if the column is valid
        if col in self.col_labels:
            col_idx = self.col_labels.index(col)
            # Check if the row is within range and the cell is empty
            if 0 <= row < 6 and board[row][col_idx] == ' ':
                return "legal"
            return "full"
        return "illegal"

    def checkFull(self):
        # Check if the top row is completely filled
        return all(self.grid[5][col] != ' ' for col in range(7))

    def checkWin(self, board, turn):
        # Check for a win in all directions
        for r in range(6):
            for c in range(7):
                if board[r][c] == turn:
                    # Check horizontal, vertical, and both diagonals
                    if (self.has_consecutive(board, r, c, 0, 1, turn) or
                        self.has_consecutive(board, r, c, 1, 0, turn) or
                        self.has_consecutive(board, r, c, 1, 1, turn) or
                        self.has_consecutive(board, r, c, 1, -1, turn)):
                        return True
        return False

    def has_consecutive(self, board_state, r, c, row_increment, col_increment, player):
        count = 0
        # Check for 4 consecutive pieces
        for i in range(4):
            r_next = r + i * row_increment
            c_next = c + i * col_increment
            # Check if the position is valid and contains the player's piece
            if 0 <= r_next < 6 and 0 <= c_next < 7 and board_state[r_next][c_next] == player:
                count += 1
            else:
                break
        return count == 4

    def checkEnd(self, board, turn):
        # Check if the game has ended (win or draw)
        if self.checkWin(board, turn):
            return True
        if self.checkFull():
            return True
        return False

    def updating_move(self, column, row):
        # Convert column letter to index
        col_idx = self.col_labels.index(column)
        # Adjust row number to match array indexing
        row_idx = row - 1
        # Check if the cell is empty
        if self.grid[row_idx][col_idx] == ' ':
            # Place the player's piece
            self.grid[row_idx][col_idx] = self.active_player
            return True
        else:
            return "occupied"

    def looping(self):
        print("Starting Game: X goes first.")
        self.printBoard()
        while True:
            # Display current player's turn
            print(f"\n{self.active_player}'s turn.")
            print("Where do you want your", self.active_player, "placed?")
            # Get and display available positions
            available_positions = self.availablePosition()
            print(f"Available positions are: {available_positions}\n")

            while True:
                # Get player's move
                move = input("Please enter column-letter and row-number (e.g., a1): ").strip().lower()
                if len(move) < 2:
                    print("Invalid input. Enter a column letter and row number (e.g., a1).")
                    continue

                column = move[0]
                row_num = move[1:]

                # Validate row number
                if not row_num.isdigit() or int(row_num) > 6 or int(row_num) < 1:
                    print("Invalid row number. Enter a valid row number between 1 and 6.")
                    continue

                # Validate column letter
                if column not in self.col_labels:
                    print("Invalid input. Enter a valid column letter between a and g.")
                    continue

                # Attempt to make the move
                move_result = self.updating_move(column, int(row_num))

                if move_result == True:
                    print("Thank you for your selection.")
                    break
                elif move_result == "occupied":
                    print("That cell is already taken. Choose another cell.")
                else:
                    print("Illegal move. Try again.")

            # Display updated board
            self.printBoard()

            # Check if the game has ended
            if self.checkEnd(self.grid, self.active_player):
                if self.checkWin(self.grid, self.active_player):
                    print(f"{self.active_player} X IS THE WINNER!!!")
                else:
                    print("DRAW! The board is completely filled.")
                # Ask for a new game
                replay = input("Another game (y/n)? ")
                if replay[0].lower() == 'y':
                    # Reset the game
                    self.grid = self.resetBoard()
                    print("New Game: X goes first.")
                    self.printBoard()
                    self.active_player = 'X'
                    continue
                else:
                    print("Thank you for playing!")
                    break

            # Switch players
            self.active_player = 'O' if self.active_player == 'X' else 'X'

def main():
    # Create a new game instance
    game_instance = ConnectFour()
    # Start the game loop
    game_instance.looping()

if __name__ == "__main__":
    main()